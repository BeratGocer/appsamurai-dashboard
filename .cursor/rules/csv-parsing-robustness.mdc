# CSV Parsing Robustness

## Flexible Header Detection
Handle multiple CSV format variations without breaking:

```typescript
// Parse header with BOM removal
let headerLine = lines[0]
if (headerLine.charCodeAt(0) === 0xFEFF) {
  headerLine = headerLine.slice(1)
}

const headers = parseCsvLine(headerLine).map((h: string) => h.trim())
const idx = (name: string) => headers.indexOf(name)

// Flexible column detection with fallbacks
const iApp = idx('app')
const iCN = idx('campaign_network')
const iAN = idx('adgroup_network')
const iDay = idx('day')
const iInst = idx('installs')
const iEcpi = idx('ecpi')
const iCost = idx('adjust_cost') >= 0 ? idx('adjust_cost') : idx('cost')
const iRev = idx('ad_revenue') >= 0 ? idx('ad_revenue') : idx('all_revenue')
const iD0 = idx('roas_d0')
const iD7 = idx('roas_d7')
const iD30 = idx('roas_d30')
const iD45 = idx('roas_d45')
```

## Campaign Network Parsing Strategy
Implement flexible parsing for different campaign network formats:

```typescript
function parseCampaignNetworkBasic(cn: string) {
  const result = { platform: 'Unknown', country: 'Global' }
  if (!cn) return result
  
  // Format 1: Structured format with pipes
  if (cn.includes('|') && cn.includes(':')) {
    const parts = cn.split('|')
    for (const p of parts) {
      const [k, v] = p.split(':')
      if (k === 'p') result.platform = v || 'Unknown'
      if (k === 'g') result.country = v || 'Global'
    }
    return result
  }
  
  // Format 2: Underscore formats (multiple variants)
  const parts = cn.split('_')
  for (const part of parts) {
    // Platform detection (any position)
    if (['AND', 'Android', 'GP'].includes(part)) result.platform = 'Android'
    if (['iOS', 'IOS'].includes(part)) result.platform = 'iOS'
    
    // Country detection (any position)
    if (['US','UK','GB','TR','DE','FR','KR','JP','CN','IN','BR','RU','CA','AU','MX'].includes(part)) {
      result.country = part
    }
  }
  return result
}
```

## Publisher Prefix Normalization
Handle various publisher/adnetwork formats:

```typescript
function normalizePublisherPrefix(adg: string): string {
  if (!adg) return 'Unknown'
  
  // Extract 3-letter prefix if exists
  const m = adg.match(/^([A-Za-z]{3})_/)
  return m ? `${m[1]}_` : adg
}
```

## Robust CSV Line Parsing
Handle quoted fields and escaped characters:

```typescript
const parseCsvLine = (line: string): string[] => {
  const out: string[] = []
  let cur = ''
  let inQuotes = false
  
  for (let i = 0; i < line.length; i++) {
    const ch = line[i]
    
    if (ch === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote
        cur += '"'
        i++
      } else {
        inQuotes = !inQuotes
      }
    } else if (ch === ',' && !inQuotes) {
      out.push(cur)
      cur = ''
    } else {
      cur += ch
    }
  }
  out.push(cur)
  return out
}
```

## Data Validation and Sanitization
Validate and clean data before database insertion:

```typescript
const toNullIfEmpty = (val: string | undefined) => {
  if (val === undefined) return null
  const t = val.trim()
  return t === '' ? null : t
}

const toNumericStringOrNull = (val: string | undefined) => {
  const v = toNullIfEmpty(val)
  if (v === null) return null
  const n = Number(v)
  if (Number.isFinite(n)) return v
  return null
}

// Row validation with error tracking
let skipped = 0
let firstError: string | null = null

for (let li = 1; li < lines.length; li++) {
  const row = lines[li]
  if (!row.trim()) continue
  
  const v = parseCsvLine(row)
  if (v.length < 5) continue
  
  try {
    const dayStr = v[iDay]
    const d = new Date(dayStr || '')
    if (!dayStr || Number.isNaN(d.getTime())) {
      skipped++
      if (!firstError) firstError = `Invalid date at line ${li+1}`
      continue
    }
    
    const installsNum = Number(v[iInst] || 0)
    if (!Number.isFinite(installsNum)) {
      skipped++
      if (!firstError) firstError = `Invalid installs at line ${li+1}`
      continue
    }
    
    // Build row object
    rows.push({
      fileId: id,
      app: v[iApp] || '',
      campaignNetwork: v[iCN] || '',
      adgroupNetwork: v[iAN] || '',
      day: d,
      installs: installsNum,
      ecpi: iEcpi >= 0 ? toNumericStringOrNull(v[iEcpi]) : null,
      adjustCost: iCost >= 0 ? toNumericStringOrNull(v[iCost]) : null,
      adRevenue: iRev >= 0 ? toNumericStringOrNull(v[iRev]) : null,
      roas_d0: iD0 >= 0 ? toNumericStringOrNull(v[iD0]) : null,
      roas_d7: iD7 >= 0 ? toNumericStringOrNull(v[iD7]) : null,
      roas_d30: iD30 >= 0 ? toNumericStringOrNull(v[iD30]) : null,
      roas_d45: iD45 >= 0 ? toNumericStringOrNull(v[iD45]) : null,
    })
  } catch {
    skipped++
    if (!firstError) firstError = `Parse error at line ${li+1}`
  }
}
```

## Critical Requirements
- ✅ Always detect format before parsing
- ✅ Handle BOM characters in CSV headers
- ✅ Support multiple column name variations
- ✅ Parse quoted fields correctly
- ✅ Validate dates and numeric values
- ✅ Track parsing errors for debugging
- ✅ Provide sensible defaults for missing data
- ✅ Never assume fixed positions in campaign_network
- ✅ Keep original values when parsing fails
- ✅ Handle empty/null values gracefully
description:
globs:
alwaysApply: true
---
