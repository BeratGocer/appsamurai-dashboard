---
description: Error handling patterns for backend API endpoints
---

# Error Handling Patterns

## HTTP Status Codes
- **400 Bad Request**: Client error (invalid data, missing fields)
- **500 Internal Server Error**: Server error (database issues, schema mismatches)

## Common Error Scenarios

### CSV Upload Errors (400)
```typescript
// Missing required data
if (iApp < 0 || iCN < 0 || iAN < 0 || iDay < 0 || iInst < 0) {
  return reply.code(400).send({ error: 'Missing required headers' })
}

// Invalid CSV format
if (v.length < 5) continue
```

### Database Errors (500)
```typescript
// Schema mismatch - column doesn't exist
// Error: "The column `CampaignRow.roas_d1` does not exist"
// Solution: Run migration to add missing columns

// Connection issues
// Error: Database connection failed
// Solution: Check Railway deployment status
```

## Error Response Format
```typescript
// Success response
reply.send({ success: true, data: result })

// Error response
reply.code(400).send({ 
  error: 'Descriptive error message',
  code: 'ERROR_CODE',
  details: 'Additional context'
})
```

## Debugging Workflow
1. **Check Console**: Browser developer tools for client errors
2. **Check HTTP Logs**: Railway logs for server errors
3. **Test Endpoints**: Use curl to test specific endpoints
4. **Verify Schema**: Use `/debug/schema` endpoint
5. **Check Migrations**: Ensure database is up to date

## Error Prevention
- ✅ Always validate input data
- ✅ Use try-catch blocks for database operations
- ✅ Test endpoints after schema changes
- ✅ Provide descriptive error messages
- ✅ Log errors for debugging

## Critical Rules
- ✅ Handle 400 errors for client-side issues
- ✅ Handle 500 errors for server-side issues
- ✅ Always test endpoints after changes
- ✅ Use debug endpoints for schema validation
- ✅ Provide clear error messages