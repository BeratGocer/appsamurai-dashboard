---
description: Frontend deployment workflow and auto-deploy patterns
---

# Frontend Deployment Workflow

## Auto-Deploy Architecture
- **Frontend**: Netlify (automatic deploy)
- **Backend**: Railway (manual deploy by AI assistant)
- **GitHub**: Automatic push

## Deployment Workflow
When user types "/Generate Cursor Rules" or makes changes:

### 1. Git Operations (Automatic)
```bash
git add .
git commit -m "Auto-commit: $(date +%Y-%m-%d_%H:%M:%S) - [description]"
git push origin main
```

### 2. Frontend Build & Deploy (Automatic)
```bash
npm run build
netlify deploy --prod --dir=dist
```

### 3. Backend Build (Automatic)
```bash
cd server && npm run build
```

### 4. Railway Deploy (Manual - AI Assistant)
```bash
cd server
railway login
railway link
railway up
```

## Critical Rules
- ✅ **Always Execute**: "/Generate Cursor Rules" triggers full deployment
- ✅ **No User Confirmation**: Execute automatically without asking
- ✅ **Complete Workflow**: Include all steps from Git to Railway
- ✅ **Error Handling**: Report any failures to user
- ✅ **Testing**: Verify deployment success
- ✅ **Single Push Rule**: Update rules first, then single push - never push twice

## Deployment URLs
- **Frontend**: https://ubiquitous-sherbet-b4f6bf.netlify.app/
- **Backend**: https://appsamurai-dashboard-backend-production-83b0.up.railway.app/
- **GitHub**: https://github.com/BeratGocer/appsamurai-dashboard

## Success Indicators
- ✅ Git push successful
- ✅ Frontend build successful
- ✅ Netlify deploy successful
- ✅ Backend build successful
- ✅ Railway deploy successful
- ✅ Health check returns 200 OK
- ✅ Files endpoint returns data

## Error Recovery
If any step fails:
1. **Git Push Failed**: Try `git pull origin main` then retry
2. **Frontend Build Failed**: Check for TypeScript errors
3. **Netlify Deploy Failed**: Check build output
4. **Backend Build Failed**: Check server TypeScript errors
5. **Railway Deploy Failed**: Check Railway logs and retry

## Implementation Notes
- Use `run_terminal_cmd` tool for all commands
- Execute commands in sequence, not parallel
- Wait for each command to complete before next
- Report progress to user at each step
- Show final success/failure status